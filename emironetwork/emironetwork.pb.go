// Code generated by protoc-gen-go. DO NOT EDIT.
// source: emironetwork.proto

package emironetwork

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Query struct {
	Query                string   `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	Count                int32    `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	All                  bool     `protobuf:"varint,3,opt,name=all,proto3" json:"all,omitempty"`
	RemoteHost           string   `protobuf:"bytes,4,opt,name=remoteHost,proto3" json:"remoteHost,omitempty"`
	Parameter            []string `protobuf:"bytes,5,rep,name=parameter,proto3" json:"parameter,omitempty"`
	Append               string   `protobuf:"bytes,6,opt,name=append,proto3" json:"append,omitempty"`
	Prepend              string   `protobuf:"bytes,7,opt,name=prepend,proto3" json:"prepend,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Query) Reset()         { *m = Query{} }
func (m *Query) String() string { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()    {}
func (*Query) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd0f112475f4ca2e, []int{0}
}

func (m *Query) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Query.Unmarshal(m, b)
}
func (m *Query) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Query.Marshal(b, m, deterministic)
}
func (m *Query) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Query.Merge(m, src)
}
func (m *Query) XXX_Size() int {
	return xxx_messageInfo_Query.Size(m)
}
func (m *Query) XXX_DiscardUnknown() {
	xxx_messageInfo_Query.DiscardUnknown(m)
}

var xxx_messageInfo_Query proto.InternalMessageInfo

func (m *Query) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *Query) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Query) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (m *Query) GetRemoteHost() string {
	if m != nil {
		return m.RemoteHost
	}
	return ""
}

func (m *Query) GetParameter() []string {
	if m != nil {
		return m.Parameter
	}
	return nil
}

func (m *Query) GetAppend() string {
	if m != nil {
		return m.Append
	}
	return ""
}

func (m *Query) GetPrepend() string {
	if m != nil {
		return m.Prepend
	}
	return ""
}

type QueryFull struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryFull) Reset()         { *m = QueryFull{} }
func (m *QueryFull) String() string { return proto.CompactTextString(m) }
func (*QueryFull) ProtoMessage()    {}
func (*QueryFull) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd0f112475f4ca2e, []int{1}
}

func (m *QueryFull) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryFull.Unmarshal(m, b)
}
func (m *QueryFull) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryFull.Marshal(b, m, deterministic)
}
func (m *QueryFull) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFull.Merge(m, src)
}
func (m *QueryFull) XXX_Size() int {
	return xxx_messageInfo_QueryFull.Size(m)
}
func (m *QueryFull) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFull.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFull proto.InternalMessageInfo

func (m *QueryFull) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type Answer struct {
	Name                 string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description          string            `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Command              string            `protobuf:"bytes,3,opt,name=command,proto3" json:"command,omitempty"`
	Language             string            `protobuf:"bytes,4,opt,name=language,proto3" json:"language,omitempty"`
	Path                 string            `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
	Script               bool              `protobuf:"varint,6,opt,name=script,proto3" json:"script,omitempty"`
	Interactive          bool              `protobuf:"varint,7,opt,name=interactive,proto3" json:"interactive,omitempty"`
	Os                   []string          `protobuf:"bytes,8,rep,name=os,proto3" json:"os,omitempty"`
	Params               map[string]string `protobuf:"bytes,9,rep,name=params,proto3" json:"params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RemoteOutput         string            `protobuf:"bytes,10,opt,name=remoteOutput,proto3" json:"remoteOutput,omitempty"`
	Id                   string            `protobuf:"bytes,11,opt,name=id,proto3" json:"id,omitempty"`
	Author               string            `protobuf:"bytes,12,opt,name=author,proto3" json:"author,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Answer) Reset()         { *m = Answer{} }
func (m *Answer) String() string { return proto.CompactTextString(m) }
func (*Answer) ProtoMessage()    {}
func (*Answer) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd0f112475f4ca2e, []int{2}
}

func (m *Answer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Answer.Unmarshal(m, b)
}
func (m *Answer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Answer.Marshal(b, m, deterministic)
}
func (m *Answer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Answer.Merge(m, src)
}
func (m *Answer) XXX_Size() int {
	return xxx_messageInfo_Answer.Size(m)
}
func (m *Answer) XXX_DiscardUnknown() {
	xxx_messageInfo_Answer.DiscardUnknown(m)
}

var xxx_messageInfo_Answer proto.InternalMessageInfo

func (m *Answer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Answer) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Answer) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *Answer) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Answer) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Answer) GetScript() bool {
	if m != nil {
		return m.Script
	}
	return false
}

func (m *Answer) GetInteractive() bool {
	if m != nil {
		return m.Interactive
	}
	return false
}

func (m *Answer) GetOs() []string {
	if m != nil {
		return m.Os
	}
	return nil
}

func (m *Answer) GetParams() map[string]string {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Answer) GetRemoteOutput() string {
	if m != nil {
		return m.RemoteOutput
	}
	return ""
}

func (m *Answer) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Answer) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

type ResponseQueryAnswer struct {
	QueryAnswers         []*Answer `protobuf:"bytes,1,rep,name=queryAnswers,proto3" json:"queryAnswers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ResponseQueryAnswer) Reset()         { *m = ResponseQueryAnswer{} }
func (m *ResponseQueryAnswer) String() string { return proto.CompactTextString(m) }
func (*ResponseQueryAnswer) ProtoMessage()    {}
func (*ResponseQueryAnswer) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd0f112475f4ca2e, []int{3}
}

func (m *ResponseQueryAnswer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResponseQueryAnswer.Unmarshal(m, b)
}
func (m *ResponseQueryAnswer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResponseQueryAnswer.Marshal(b, m, deterministic)
}
func (m *ResponseQueryAnswer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseQueryAnswer.Merge(m, src)
}
func (m *ResponseQueryAnswer) XXX_Size() int {
	return xxx_messageInfo_ResponseQueryAnswer.Size(m)
}
func (m *ResponseQueryAnswer) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseQueryAnswer.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseQueryAnswer proto.InternalMessageInfo

func (m *ResponseQueryAnswer) GetQueryAnswers() []*Answer {
	if m != nil {
		return m.QueryAnswers
	}
	return nil
}

type Response struct {
	Succeed              bool     `protobuf:"varint,1,opt,name=succeed,proto3" json:"succeed,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd0f112475f4ca2e, []int{4}
}

func (m *Response) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Response.Unmarshal(m, b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Response.Marshal(b, m, deterministic)
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return xxx_messageInfo_Response.Size(m)
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetSucceed() bool {
	if m != nil {
		return m.Succeed
	}
	return false
}

func (m *Response) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*Query)(nil), "emironetwork.Query")
	proto.RegisterType((*QueryFull)(nil), "emironetwork.QueryFull")
	proto.RegisterType((*Answer)(nil), "emironetwork.Answer")
	proto.RegisterMapType((map[string]string)(nil), "emironetwork.Answer.ParamsEntry")
	proto.RegisterType((*ResponseQueryAnswer)(nil), "emironetwork.ResponseQueryAnswer")
	proto.RegisterType((*Response)(nil), "emironetwork.Response")
}

func init() {
	proto.RegisterFile("emironetwork.proto", fileDescriptor_bd0f112475f4ca2e)
}

var fileDescriptor_bd0f112475f4ca2e = []byte{
	// 558 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcf, 0x6e, 0xd4, 0x3e,
	0x10, 0x6e, 0x92, 0x66, 0x9b, 0xcc, 0xae, 0x7e, 0xaa, 0xdc, 0xaa, 0x3f, 0x6b, 0x85, 0x20, 0xe4,
	0xb4, 0xa7, 0x0a, 0x95, 0x03, 0xcb, 0xbf, 0x03, 0x52, 0x17, 0x71, 0xa2, 0x60, 0x78, 0x01, 0x93,
	0x8c, 0xda, 0xa8, 0x89, 0x9d, 0x3a, 0x4e, 0xb7, 0x7d, 0x0e, 0x9e, 0x85, 0x3b, 0x8f, 0x86, 0x3c,
	0x49, 0xba, 0xbb, 0x52, 0x40, 0xea, 0x6d, 0xbe, 0xcf, 0x9e, 0x6f, 0xe6, 0xf3, 0x4c, 0x02, 0x0c,
	0xab, 0xc2, 0x68, 0x85, 0x76, 0xad, 0xcd, 0xf5, 0x69, 0x6d, 0xb4, 0xd5, 0x6c, 0xb6, 0xcd, 0xa5,
	0xbf, 0x3c, 0x08, 0xbf, 0xb6, 0x68, 0xee, 0xd9, 0x31, 0x84, 0x37, 0x2e, 0xe0, 0x5e, 0xe2, 0x2d,
	0x62, 0xd1, 0x01, 0xc7, 0x66, 0xba, 0x55, 0x96, 0xfb, 0x89, 0xb7, 0x08, 0x45, 0x07, 0xd8, 0x21,
	0x04, 0xb2, 0x2c, 0x79, 0x90, 0x78, 0x8b, 0x48, 0xb8, 0x90, 0x3d, 0x05, 0x30, 0x58, 0x69, 0x8b,
	0x9f, 0x74, 0x63, 0xf9, 0x3e, 0x49, 0x6c, 0x31, 0xec, 0x09, 0xc4, 0xb5, 0x34, 0xb2, 0x42, 0x8b,
	0x86, 0x87, 0x49, 0xb0, 0x88, 0xc5, 0x86, 0x60, 0x27, 0x30, 0x91, 0x75, 0x8d, 0x2a, 0xe7, 0x13,
	0xca, 0xec, 0x11, 0xe3, 0x70, 0x50, 0x1b, 0xa4, 0x83, 0x03, 0x3a, 0x18, 0x60, 0xfa, 0x0c, 0x62,
	0x6a, 0xfb, 0x63, 0x5b, 0x96, 0x8c, 0xc1, 0x7e, 0x2e, 0xad, 0xa4, 0xce, 0x67, 0x82, 0xe2, 0xf4,
	0x67, 0x00, 0x93, 0x0f, 0xaa, 0x59, 0xa3, 0x71, 0xc7, 0x4a, 0x56, 0xd8, 0x1b, 0xa3, 0x98, 0x25,
	0x30, 0xcd, 0xb1, 0xc9, 0x4c, 0x51, 0xdb, 0x42, 0x2b, 0x72, 0x17, 0x8b, 0x6d, 0xca, 0xd5, 0xce,
	0x74, 0x55, 0x49, 0x95, 0x93, 0xcf, 0x58, 0x0c, 0x90, 0xcd, 0x21, 0x2a, 0xa5, 0xba, 0x6c, 0xe5,
	0x25, 0xf6, 0x4e, 0x1f, 0xb0, 0xab, 0x55, 0x4b, 0x7b, 0xc5, 0xc3, 0xae, 0x96, 0x8b, 0x9d, 0xbb,
	0x4e, 0x96, 0xdc, 0x45, 0xa2, 0x47, 0xae, 0x87, 0x42, 0x59, 0x34, 0x32, 0xb3, 0xc5, 0x2d, 0x92,
	0xc3, 0x48, 0x6c, 0x53, 0xec, 0x3f, 0xf0, 0x75, 0xc3, 0x23, 0x7a, 0x2e, 0x5f, 0x37, 0x6c, 0x09,
	0x13, 0x7a, 0xb4, 0x86, 0xc7, 0x49, 0xb0, 0x98, 0x9e, 0x25, 0xa7, 0x3b, 0x03, 0xee, 0xfc, 0x9e,
	0x7e, 0xa1, 0x2b, 0x2b, 0x65, 0xcd, 0xbd, 0xe8, 0xef, 0xb3, 0x14, 0x66, 0xdd, 0x34, 0x2e, 0x5a,
	0x5b, 0xb7, 0x96, 0x03, 0xf5, 0xb7, 0xc3, 0xb9, 0x6a, 0x45, 0xce, 0xa7, 0x74, 0xe2, 0x17, 0x39,
	0x4d, 0xa5, 0xb5, 0x57, 0xda, 0xf0, 0x59, 0x3f, 0x15, 0x42, 0xf3, 0xd7, 0x30, 0xdd, 0x2a, 0xe1,
	0x96, 0xe1, 0x1a, 0x87, 0xb5, 0x71, 0xa1, 0x5b, 0x9a, 0x5b, 0x59, 0xb6, 0xd8, 0x3f, 0x6b, 0x07,
	0xde, 0xf8, 0x4b, 0x2f, 0xbd, 0x80, 0x23, 0x81, 0x4d, 0xad, 0x55, 0x83, 0x34, 0xbe, 0x7e, 0x42,
	0x4b, 0x98, 0xdd, 0x6c, 0x60, 0xc3, 0x3d, 0x72, 0x77, 0x3c, 0xe6, 0x4e, 0xec, 0xdc, 0x4c, 0x97,
	0x10, 0x0d, 0x82, 0x6e, 0x62, 0x4d, 0x9b, 0x65, 0x88, 0x39, 0x35, 0x13, 0x89, 0x01, 0x3e, 0x2c,
	0x88, 0xbf, 0x59, 0x90, 0xb3, 0xdf, 0x01, 0x84, 0x2b, 0xa7, 0xcf, 0x56, 0x10, 0x37, 0xa8, 0xf2,
	0xee, 0x33, 0x38, 0xda, 0x2d, 0x4a, 0xe4, 0xfc, 0xf9, 0x2e, 0x39, 0x62, 0x21, 0xdd, 0x63, 0xaf,
	0x20, 0x72, 0x32, 0xdf, 0xae, 0xf4, 0x7a, 0x5c, 0x65, 0xd4, 0xcf, 0x26, 0x71, 0x75, 0x87, 0xd9,
	0xe3, 0x12, 0xdf, 0xc1, 0x81, 0x4b, 0xfc, 0x8c, 0x6b, 0xf6, 0xff, 0x48, 0x9e, 0xfb, 0x36, 0xe6,
	0x27, 0xe3, 0xad, 0xa7, 0x7b, 0xec, 0x2d, 0x80, 0xcb, 0x3e, 0xc7, 0x12, 0x2d, 0x8e, 0x17, 0xfe,
	0x7b, 0xf2, 0x7b, 0x00, 0xbc, 0xc3, 0x4c, 0xd0, 0xfe, 0x3c, 0x32, 0xf9, 0x85, 0xc7, 0xce, 0xe1,
	0x70, 0xb0, 0xfc, 0x5d, 0xf7, 0x22, 0xa3, 0x2e, 0xff, 0xa5, 0xf2, 0x63, 0x42, 0x7f, 0xb4, 0x97,
	0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x5b, 0xbf, 0x59, 0x12, 0xe7, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// EmiroClient is the client API for Emiro service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EmiroClient interface {
	SendQuery(ctx context.Context, in *Query, opts ...grpc.CallOption) (*ResponseQueryAnswer, error)
	SendShow(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Answer, error)
	SendExec(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Answer, error)
	SendNew(ctx context.Context, in *QueryFull, opts ...grpc.CallOption) (*Response, error)
	SendDelete(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Response, error)
	ExecRemote(ctx context.Context, in *Query, opts ...grpc.CallOption) (Emiro_ExecRemoteClient, error)
	SendExecToRemote(ctx context.Context, in *Answer, opts ...grpc.CallOption) (Emiro_SendExecToRemoteClient, error)
}

type emiroClient struct {
	cc grpc.ClientConnInterface
}

func NewEmiroClient(cc grpc.ClientConnInterface) EmiroClient {
	return &emiroClient{cc}
}

func (c *emiroClient) SendQuery(ctx context.Context, in *Query, opts ...grpc.CallOption) (*ResponseQueryAnswer, error) {
	out := new(ResponseQueryAnswer)
	err := c.cc.Invoke(ctx, "/emironetwork.Emiro/sendQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emiroClient) SendShow(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Answer, error) {
	out := new(Answer)
	err := c.cc.Invoke(ctx, "/emironetwork.Emiro/sendShow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emiroClient) SendExec(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Answer, error) {
	out := new(Answer)
	err := c.cc.Invoke(ctx, "/emironetwork.Emiro/sendExec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emiroClient) SendNew(ctx context.Context, in *QueryFull, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/emironetwork.Emiro/sendNew", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emiroClient) SendDelete(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/emironetwork.Emiro/sendDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emiroClient) ExecRemote(ctx context.Context, in *Query, opts ...grpc.CallOption) (Emiro_ExecRemoteClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Emiro_serviceDesc.Streams[0], "/emironetwork.Emiro/execRemote", opts...)
	if err != nil {
		return nil, err
	}
	x := &emiroExecRemoteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Emiro_ExecRemoteClient interface {
	Recv() (*Response, error)
	grpc.ClientStream
}

type emiroExecRemoteClient struct {
	grpc.ClientStream
}

func (x *emiroExecRemoteClient) Recv() (*Response, error) {
	m := new(Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *emiroClient) SendExecToRemote(ctx context.Context, in *Answer, opts ...grpc.CallOption) (Emiro_SendExecToRemoteClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Emiro_serviceDesc.Streams[1], "/emironetwork.Emiro/sendExecToRemote", opts...)
	if err != nil {
		return nil, err
	}
	x := &emiroSendExecToRemoteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Emiro_SendExecToRemoteClient interface {
	Recv() (*Response, error)
	grpc.ClientStream
}

type emiroSendExecToRemoteClient struct {
	grpc.ClientStream
}

func (x *emiroSendExecToRemoteClient) Recv() (*Response, error) {
	m := new(Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// EmiroServer is the server API for Emiro service.
type EmiroServer interface {
	SendQuery(context.Context, *Query) (*ResponseQueryAnswer, error)
	SendShow(context.Context, *Query) (*Answer, error)
	SendExec(context.Context, *Query) (*Answer, error)
	SendNew(context.Context, *QueryFull) (*Response, error)
	SendDelete(context.Context, *Query) (*Response, error)
	ExecRemote(*Query, Emiro_ExecRemoteServer) error
	SendExecToRemote(*Answer, Emiro_SendExecToRemoteServer) error
}

// UnimplementedEmiroServer can be embedded to have forward compatible implementations.
type UnimplementedEmiroServer struct {
}

func (*UnimplementedEmiroServer) SendQuery(ctx context.Context, req *Query) (*ResponseQueryAnswer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendQuery not implemented")
}
func (*UnimplementedEmiroServer) SendShow(ctx context.Context, req *Query) (*Answer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendShow not implemented")
}
func (*UnimplementedEmiroServer) SendExec(ctx context.Context, req *Query) (*Answer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendExec not implemented")
}
func (*UnimplementedEmiroServer) SendNew(ctx context.Context, req *QueryFull) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendNew not implemented")
}
func (*UnimplementedEmiroServer) SendDelete(ctx context.Context, req *Query) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendDelete not implemented")
}
func (*UnimplementedEmiroServer) ExecRemote(req *Query, srv Emiro_ExecRemoteServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecRemote not implemented")
}
func (*UnimplementedEmiroServer) SendExecToRemote(req *Answer, srv Emiro_SendExecToRemoteServer) error {
	return status.Errorf(codes.Unimplemented, "method SendExecToRemote not implemented")
}

func RegisterEmiroServer(s *grpc.Server, srv EmiroServer) {
	s.RegisterService(&_Emiro_serviceDesc, srv)
}

func _Emiro_SendQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmiroServer).SendQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/emironetwork.Emiro/SendQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmiroServer).SendQuery(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _Emiro_SendShow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmiroServer).SendShow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/emironetwork.Emiro/SendShow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmiroServer).SendShow(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _Emiro_SendExec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmiroServer).SendExec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/emironetwork.Emiro/SendExec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmiroServer).SendExec(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _Emiro_SendNew_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFull)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmiroServer).SendNew(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/emironetwork.Emiro/SendNew",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmiroServer).SendNew(ctx, req.(*QueryFull))
	}
	return interceptor(ctx, in, info, handler)
}

func _Emiro_SendDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmiroServer).SendDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/emironetwork.Emiro/SendDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmiroServer).SendDelete(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _Emiro_ExecRemote_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Query)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EmiroServer).ExecRemote(m, &emiroExecRemoteServer{stream})
}

type Emiro_ExecRemoteServer interface {
	Send(*Response) error
	grpc.ServerStream
}

type emiroExecRemoteServer struct {
	grpc.ServerStream
}

func (x *emiroExecRemoteServer) Send(m *Response) error {
	return x.ServerStream.SendMsg(m)
}

func _Emiro_SendExecToRemote_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Answer)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EmiroServer).SendExecToRemote(m, &emiroSendExecToRemoteServer{stream})
}

type Emiro_SendExecToRemoteServer interface {
	Send(*Response) error
	grpc.ServerStream
}

type emiroSendExecToRemoteServer struct {
	grpc.ServerStream
}

func (x *emiroSendExecToRemoteServer) Send(m *Response) error {
	return x.ServerStream.SendMsg(m)
}

var _Emiro_serviceDesc = grpc.ServiceDesc{
	ServiceName: "emironetwork.Emiro",
	HandlerType: (*EmiroServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "sendQuery",
			Handler:    _Emiro_SendQuery_Handler,
		},
		{
			MethodName: "sendShow",
			Handler:    _Emiro_SendShow_Handler,
		},
		{
			MethodName: "sendExec",
			Handler:    _Emiro_SendExec_Handler,
		},
		{
			MethodName: "sendNew",
			Handler:    _Emiro_SendNew_Handler,
		},
		{
			MethodName: "sendDelete",
			Handler:    _Emiro_SendDelete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "execRemote",
			Handler:       _Emiro_ExecRemote_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "sendExecToRemote",
			Handler:       _Emiro_SendExecToRemote_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "emironetwork.proto",
}
