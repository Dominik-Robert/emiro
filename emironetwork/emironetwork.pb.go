// Code generated by protoc-gen-go. DO NOT EDIT.
// source: emironetwork.proto

package emironetwork

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Query struct {
	Query                string   `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	Count                int32    `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	All                  bool     `protobuf:"varint,3,opt,name=all,proto3" json:"all,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Query) Reset()         { *m = Query{} }
func (m *Query) String() string { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()    {}
func (*Query) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd0f112475f4ca2e, []int{0}
}

func (m *Query) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Query.Unmarshal(m, b)
}
func (m *Query) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Query.Marshal(b, m, deterministic)
}
func (m *Query) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Query.Merge(m, src)
}
func (m *Query) XXX_Size() int {
	return xxx_messageInfo_Query.Size(m)
}
func (m *Query) XXX_DiscardUnknown() {
	xxx_messageInfo_Query.DiscardUnknown(m)
}

var xxx_messageInfo_Query proto.InternalMessageInfo

func (m *Query) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *Query) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Query) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

type QueryAnswer struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description          string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Language             string   `protobuf:"bytes,3,opt,name=language,proto3" json:"language,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryAnswer) Reset()         { *m = QueryAnswer{} }
func (m *QueryAnswer) String() string { return proto.CompactTextString(m) }
func (*QueryAnswer) ProtoMessage()    {}
func (*QueryAnswer) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd0f112475f4ca2e, []int{1}
}

func (m *QueryAnswer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryAnswer.Unmarshal(m, b)
}
func (m *QueryAnswer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryAnswer.Marshal(b, m, deterministic)
}
func (m *QueryAnswer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAnswer.Merge(m, src)
}
func (m *QueryAnswer) XXX_Size() int {
	return xxx_messageInfo_QueryAnswer.Size(m)
}
func (m *QueryAnswer) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAnswer.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAnswer proto.InternalMessageInfo

func (m *QueryAnswer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryAnswer) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *QueryAnswer) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

type Answer struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description          string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Command              string   `protobuf:"bytes,3,opt,name=command,proto3" json:"command,omitempty"`
	Language             string   `protobuf:"bytes,4,opt,name=language,proto3" json:"language,omitempty"`
	Path                 string   `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
	Script               bool     `protobuf:"varint,6,opt,name=script,proto3" json:"script,omitempty"`
	Os                   []string `protobuf:"bytes,7,rep,name=os,proto3" json:"os,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Answer) Reset()         { *m = Answer{} }
func (m *Answer) String() string { return proto.CompactTextString(m) }
func (*Answer) ProtoMessage()    {}
func (*Answer) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd0f112475f4ca2e, []int{2}
}

func (m *Answer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Answer.Unmarshal(m, b)
}
func (m *Answer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Answer.Marshal(b, m, deterministic)
}
func (m *Answer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Answer.Merge(m, src)
}
func (m *Answer) XXX_Size() int {
	return xxx_messageInfo_Answer.Size(m)
}
func (m *Answer) XXX_DiscardUnknown() {
	xxx_messageInfo_Answer.DiscardUnknown(m)
}

var xxx_messageInfo_Answer proto.InternalMessageInfo

func (m *Answer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Answer) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Answer) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *Answer) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Answer) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Answer) GetScript() bool {
	if m != nil {
		return m.Script
	}
	return false
}

func (m *Answer) GetOs() []string {
	if m != nil {
		return m.Os
	}
	return nil
}

type ResponseQueryAnswer struct {
	QueryAnswers         []*QueryAnswer `protobuf:"bytes,1,rep,name=queryAnswers,proto3" json:"queryAnswers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ResponseQueryAnswer) Reset()         { *m = ResponseQueryAnswer{} }
func (m *ResponseQueryAnswer) String() string { return proto.CompactTextString(m) }
func (*ResponseQueryAnswer) ProtoMessage()    {}
func (*ResponseQueryAnswer) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd0f112475f4ca2e, []int{3}
}

func (m *ResponseQueryAnswer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResponseQueryAnswer.Unmarshal(m, b)
}
func (m *ResponseQueryAnswer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResponseQueryAnswer.Marshal(b, m, deterministic)
}
func (m *ResponseQueryAnswer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseQueryAnswer.Merge(m, src)
}
func (m *ResponseQueryAnswer) XXX_Size() int {
	return xxx_messageInfo_ResponseQueryAnswer.Size(m)
}
func (m *ResponseQueryAnswer) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseQueryAnswer.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseQueryAnswer proto.InternalMessageInfo

func (m *ResponseQueryAnswer) GetQueryAnswers() []*QueryAnswer {
	if m != nil {
		return m.QueryAnswers
	}
	return nil
}

func init() {
	proto.RegisterType((*Query)(nil), "emironetwork.Query")
	proto.RegisterType((*QueryAnswer)(nil), "emironetwork.QueryAnswer")
	proto.RegisterType((*Answer)(nil), "emironetwork.Answer")
	proto.RegisterType((*ResponseQueryAnswer)(nil), "emironetwork.ResponseQueryAnswer")
}

func init() {
	proto.RegisterFile("emironetwork.proto", fileDescriptor_bd0f112475f4ca2e)
}

var fileDescriptor_bd0f112475f4ca2e = []byte{
	// 314 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x92, 0xb1, 0x4e, 0xc3, 0x30,
	0x18, 0x84, 0x71, 0xd3, 0xa4, 0xcd, 0xdf, 0x0a, 0xa1, 0xbf, 0x15, 0x32, 0x9d, 0x42, 0xa6, 0x4c,
	0x1d, 0xca, 0xc0, 0xc4, 0xc0, 0x90, 0x07, 0xc0, 0x65, 0x47, 0x26, 0xb5, 0xda, 0x8a, 0xc6, 0x4e,
	0xed, 0x54, 0x85, 0xb7, 0xe2, 0x11, 0x78, 0x34, 0x64, 0xa7, 0x40, 0x8c, 0xb2, 0x20, 0xb6, 0xbb,
	0x93, 0xef, 0xbb, 0xc8, 0x0e, 0xa0, 0x28, 0xb7, 0x5a, 0x49, 0x51, 0x1f, 0x95, 0x7e, 0x99, 0x57,
	0x5a, 0xd5, 0x0a, 0xc7, 0xed, 0x2c, 0xcd, 0x21, 0x7c, 0x38, 0x08, 0xfd, 0x86, 0x53, 0x08, 0xf7,
	0x56, 0x50, 0x92, 0x90, 0x2c, 0x66, 0x8d, 0xb1, 0x69, 0xa1, 0x0e, 0xb2, 0xa6, 0xbd, 0x84, 0x64,
	0x21, 0x6b, 0x0c, 0x5e, 0x40, 0xc0, 0x77, 0x3b, 0x1a, 0x24, 0x24, 0x1b, 0x32, 0x2b, 0xd3, 0x27,
	0x18, 0x39, 0xcc, 0xbd, 0x34, 0x47, 0xa1, 0x11, 0xa1, 0x2f, 0x79, 0x29, 0x4e, 0x2c, 0xa7, 0x31,
	0x81, 0xd1, 0x4a, 0x98, 0x42, 0x6f, 0xab, 0x7a, 0xab, 0xa4, 0x03, 0xc6, 0xac, 0x1d, 0xe1, 0x0c,
	0x86, 0x3b, 0x2e, 0xd7, 0x07, 0xbe, 0x16, 0x8e, 0x1d, 0xb3, 0x6f, 0x9f, 0xbe, 0x13, 0x88, 0xfe,
	0x05, 0xa7, 0x30, 0x28, 0x54, 0x59, 0x72, 0xb9, 0x3a, 0xb1, 0xbf, 0xac, 0x37, 0xdb, 0xf7, 0x67,
	0xed, 0x56, 0xc5, 0xeb, 0x0d, 0x0d, 0x9b, 0x2d, 0xab, 0xf1, 0x12, 0xa2, 0x06, 0x4b, 0x23, 0x77,
	0x01, 0x27, 0x87, 0xe7, 0xd0, 0x53, 0x86, 0x0e, 0x92, 0x20, 0x8b, 0x59, 0x4f, 0x99, 0xf4, 0x11,
	0x26, 0x4c, 0x98, 0x4a, 0x49, 0x23, 0xda, 0x77, 0x73, 0x07, 0xe3, 0xfd, 0x8f, 0x35, 0x94, 0x24,
	0x41, 0x36, 0x5a, 0x5c, 0xcd, 0xbd, 0xa7, 0x6a, 0x15, 0x98, 0x77, 0x7c, 0xf1, 0x41, 0x20, 0xcc,
	0xed, 0x51, 0xcc, 0x21, 0x5e, 0x0a, 0xb9, 0x6a, 0x9e, 0x6f, 0xd2, 0xd1, 0x9f, 0x5d, 0xfb, 0x61,
	0xc7, 0xd7, 0xa4, 0x67, 0x78, 0x0b, 0x43, 0x8b, 0x59, 0x6e, 0xd4, 0xb1, 0x9b, 0x32, 0xf5, 0xc3,
	0xdf, 0xc5, 0xfc, 0x55, 0x14, 0x7f, 0x2a, 0x3e, 0x47, 0xee, 0x47, 0xbc, 0xf9, 0x0c, 0x00, 0x00,
	0xff, 0xff, 0xb4, 0xb9, 0xc7, 0xe9, 0x9e, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// EmiroClient is the client API for Emiro service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EmiroClient interface {
	SendQuery(ctx context.Context, in *Query, opts ...grpc.CallOption) (*ResponseQueryAnswer, error)
	SendShow(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Answer, error)
	SendExec(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Answer, error)
}

type emiroClient struct {
	cc grpc.ClientConnInterface
}

func NewEmiroClient(cc grpc.ClientConnInterface) EmiroClient {
	return &emiroClient{cc}
}

func (c *emiroClient) SendQuery(ctx context.Context, in *Query, opts ...grpc.CallOption) (*ResponseQueryAnswer, error) {
	out := new(ResponseQueryAnswer)
	err := c.cc.Invoke(ctx, "/emironetwork.Emiro/SendQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emiroClient) SendShow(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Answer, error) {
	out := new(Answer)
	err := c.cc.Invoke(ctx, "/emironetwork.Emiro/SendShow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emiroClient) SendExec(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Answer, error) {
	out := new(Answer)
	err := c.cc.Invoke(ctx, "/emironetwork.Emiro/SendExec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EmiroServer is the server API for Emiro service.
type EmiroServer interface {
	SendQuery(context.Context, *Query) (*ResponseQueryAnswer, error)
	SendShow(context.Context, *Query) (*Answer, error)
	SendExec(context.Context, *Query) (*Answer, error)
}

// UnimplementedEmiroServer can be embedded to have forward compatible implementations.
type UnimplementedEmiroServer struct {
}

func (*UnimplementedEmiroServer) SendQuery(ctx context.Context, req *Query) (*ResponseQueryAnswer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendQuery not implemented")
}
func (*UnimplementedEmiroServer) SendShow(ctx context.Context, req *Query) (*Answer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendShow not implemented")
}
func (*UnimplementedEmiroServer) SendExec(ctx context.Context, req *Query) (*Answer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendExec not implemented")
}

func RegisterEmiroServer(s *grpc.Server, srv EmiroServer) {
	s.RegisterService(&_Emiro_serviceDesc, srv)
}

func _Emiro_SendQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmiroServer).SendQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/emironetwork.Emiro/SendQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmiroServer).SendQuery(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _Emiro_SendShow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmiroServer).SendShow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/emironetwork.Emiro/SendShow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmiroServer).SendShow(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _Emiro_SendExec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmiroServer).SendExec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/emironetwork.Emiro/SendExec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmiroServer).SendExec(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

var _Emiro_serviceDesc = grpc.ServiceDesc{
	ServiceName: "emironetwork.Emiro",
	HandlerType: (*EmiroServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendQuery",
			Handler:    _Emiro_SendQuery_Handler,
		},
		{
			MethodName: "SendShow",
			Handler:    _Emiro_SendShow_Handler,
		},
		{
			MethodName: "SendExec",
			Handler:    _Emiro_SendExec_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "emironetwork.proto",
}
